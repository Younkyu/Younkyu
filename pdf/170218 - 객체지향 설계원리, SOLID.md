###**170218 - 객체지향 설계원리, SOLID**


 우리는 객체지향 패러다임 안에서 애플리케이션을 만들고 있다. '왜 객체지향적으로 설계해야 하는가?'에 대한 대답은 명확하다. 개발자는 단순한 '구현자'가 아닌, '설계자'가 되어야 하기 때문이다. 
 프로그램이 돌아가기만 한다고 해서 개발자인 것은 아니다. 우리가 프로그램을 만들고 나면, 다른 사람들이 그 프로그램을 수정할 수 있어야 유지, 보수 업무를 할 수 있기 때문이다. 또한 깔끔한 설계는 하나의 부품처럼 기능하게 되어, 언제든지 그 기능들을 다시 사용할 수 있게 된다. 여기에서 쓰는 사용법 창고 페이지도 이러한 활용을 위해서 제작하고 있는 것이다. 

 그렇기 때문에 우리는 객체지향이 추구하는 5대 원리, SOLID에 대해서 알아보고, 단지 레고처럼 부품을 쓰는 것이라는 이해보다 한단계 더 나아가 보도록 하자.

###**(1)SRP (단일책임의 원칙: Single Responsibility Principle)**

 첫번째는 단일책임의 원칙이다. 클래스는 단하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는데 집중되어 있어야 한다는 원칙이다. 예를 들어 어떤 DATA를 LOAD해야하는 CLASS를 만들었다면, 여기에서는 DATALOAD기능 외에 관련되지 않은 모든 기능은 다른 클래스에서 구현해야 한다. 이것은 객체지향의 가장 기본적인 원칙이고, '레고의 부품'처럼 쓴다는 비유에 가장 잘 들어맞는 말일 것이다. 

###**(2)OCP (개방폐쇄의 원칙: Open Close Principle)**

 소프트웨어의 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리이다. 우리가 어떠한 CLASS를 만들었을 때, 이것에 대한 수정을 하고 싶다면 새로 클래스를 만든 후, 원래 클래스를 상속 받아야한다는 원리이다. 이것의 가장 가까운 예는 안드로이드 MainActivity가 상속받는 AppCompat이다. 안드로이드 초기에는 Activity를 상속 받았지만, Activity클래스를 수정하는 것이 아니라, 그 클래스를 상속 받아서 기능을 추가하고 수정하는 것이다. 이를 가능하게 하는 중요 메커니즘은 추상화와 다형성이다.

###**(3)LSP (리스코브 치환의 원칙: The Liskov Substitution Principle)**
 
  가장 이해가 어려운 원칙이다. 한마디로 한다면 "서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다."이다. 즉, 서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다. 인터페이스에서 draw라는 함수를 강제한다면, 우리는 draw함수에 그림을 그리는 로직을 작성해야하지, 다른 행동을 하게 만들면 설계가 어려워진다는 의미라고 생각하면 쉬울 것이다.


###**(4) ISP (인터페이스 분리의 원칙: Interface Segregation Principle)**


 간단하다. 인터페이스를 최대한 쪼개라는 의미이다. '하나의 범용 인터페이스보다는 세분화된 여러개의 인터페이스가 낫다'라고 이해를 하고 넘어가자. 이렇게 해야 하는 이유는 사용하지 않는 인터페이스를 여러곳에서 사용한다면 혼란이 발생할 수 있고, 즉 유지보수의 어려움이 생기기 때문에 인터페이스는 최대한 쪼개서 사용하는 것이 좋다.

###**(5)DIP (의존성역전의 원칙: Dependency Inversion Principle)**


 의존관계가 역전되면 안된다는 것이다. 예를 들어 B는 A의 하위인데, B에서 A의 클래스를 직접 구현하면 안된다는 것이다. 의존관계가 역전되기 때문이다. 따라서 B가 A의 메소드를 사용하고 싶다면 직접 구현이 아닌 간접 구현, 즉 인터페이스로써 구현해서 사용해야 하는 것이다. 


