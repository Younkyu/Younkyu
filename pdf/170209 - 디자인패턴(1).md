##**170209 - 디자인패턴(1)**

 우리가 애플리케이션을 만들 때 개발하는 과정을 계속해서 거치다 보면 설계의 형태가 비슷하게 나타나는 것들이 많아지게 된다. 그리고 이런 패턴들을 분석해서 정리해둔 것을 디자인패턴이라고 한다.

 우리가 디자인패턴을 알아야하는 이유는 앱을 구성할 때 보통 어떤식으로 설계를 하는지에 대해서 감을 잡아야하기 때문이다. 디자인 패턴은 우리가 어떤 앱을 만들 때 표준에 가까운 구조로 만들 수 있게 해주는 도구라고 할 수 있다. 따라서 디자인패턴을 우리가 하나의 도구처럼 사용하고 그 구조를 이해한다면, 구조적 부분에서의 객체지향을 완성해 나갈 수 있을 것이다. 오늘은 Singleton, Multiton, Proxy, Decorator, Template, Factory, Strategy, StrategyCallBack 패턴에 대해서 개념을 간략이 이해하고 넘어가도록 하자.


####**Singleton**
 Singleton이란 간단히 말해서 어떤 클래스의 new를 하지 못하게 하는 것이라고 할 수 있다. new를 하지않고 따로 getInstance라는 함수로 빼서, class내의 변수 수정등을 다같이 공유하는 이점이 있다. 즉, 공공재의 개념이다. 의존성은 낮추고, 응집도를 높일 수 있다는 장점이 있다.

####**Multiton**
 Multiton은 이와 반대로, 새로운 객체를 만드는 것을 강제한다. 즉 각각 개별적인 객체를 만들고자 할 때 사용하는 방식이다. 이럴 때도 new를 사용하기보다는 setInstance라는 함수를 따로 빼서 사용한다. 이 경우에는 new라는 의존성(dependenc)을 제거해준다는 장점이 있다. 주로 안의 변수등을 개별적으로 바꿔 사용해야 할 때 사용한다.

###**Proxy, Decorator**
 대행자라고 생각하면 쉬울 것이다. 중간에 다른 기능 또는 요구사항을 처리한 후 클라이언트 요청에 대한 원본데이터는 변형하지 않고 그대로 전달한다. 여기에서 중요한 것은 대행을 하면서 중간의 데이터를 변형하지 않으면 Proxy, 변형하면 Decorator라는 사실이다. 디자인패턴을 구분할 때는 중간에 데이터가 변형이 되었는지에 초점을 맞춰서 구별하면 된다.
 
#####**순서**

1. 나를담을 변수를 선언 
2. 생성을 금지 
3. 인스턴스를 체크해서 넘겨준다.
4. 대행함수 구현

####**Template**
 부모클래스에 있는 추상함수를 상속받은 자식 클래스가 구현한 메서드를 호출하는 패턴이다. 이에 대한 것은 코드로 이해하는 것이 더 쉬울 것이다. 

**부모클래스**

	package com.younkyu.design.templatemethod;
	
	public abstract class TemplateMethod {
		
		public void play() {
			System.out.println("플레이가 시작됩니다.");
			jump();
		}
	
		public abstract void jump();
		
	}

**자식클래스**

	package com.younkyu.design.templatemethod;
	
	public class Frog extends TemplateMethod {
	
		@Override
		public void jump() {
			// TODO Auto-generated method stub
			System.out.println("폴짝폴짝");
		}
	
		
	}

 즉, Rabbit에서 play()를 사용할 때, jump를 구현해서 사용해야 하기 때문에, 이러한 패턴을 사용하는 것이다. 이것의 장점은 내가 어떤 함수를 템플릿으로 정해놓으면, 밑의 함수에서 자유롭게 구성해서 사용할 수 있다는 것이다.

####**Factory**
 객체를 생성해주는 패턴이다. 확장한 부모 클래스의 메소드를 오버라이드해서 반환해준다. 
 
  팩토리메서드 = 객체를 생성해주는 패턴, 확장한 부모 클래스의 메서드를 오버라이드해서 반환해준다. Templelate 패턴과도 비슷한 개념이라고 할 수 있는데, 먼저 공장을 만들어 놓고, 공장안에 어떤 제품을 만드는 형식을 정해놓는다. 그렇게 하면 처음엔 tv를 만들 수도 있고, 나중에는 telephone도 만들 수 있는 것이다. 공장을 지어서 비슷한 형식의 객체를 쉽게 많이 만들어 낼 수 있다는 장점이 있다.

####**Strategy, StrategyCallBack**

 Templelate 패턴과 유사한데, Templelate패턴이 상속을 이용하는 반면에 Strategy 패턴은 객체를 주입해서 다양한 결과를 도출 할 수 있다는 장점이 있다. 기본적으로 아래 3요소가 필요하다.
 
 1. 전략 : 실제 로직을 구현하는 객체
 2. 컨텍스트 : 전략을 사용하는 객체
 3. 클라이언트 : 전략객체를 생성한 후 컨텍스트에 주입하는 객체

 Templelate 패턴은 어떤 행동을 하는 객체에서 내가 사용하는 함수를 정의했다. (Templelate class에서 행동을 정의하고, 객체인 Rabbit에서는 정해진 것을 사용) 하지만 여기에선 반대로 Rabbit이 어떤 것을 할지 정한다고 생각하면 이해가 편할 것이다. Template는 Template가 한개이고 나머지 Rabbit이 여러가지라면, 여기에서는 Rabbit이 하나이고 Template가 여러가지인 반대 상황을 생각하면 된다. 즉 행동을 정해놓고 객체를 만들면 Template, 객체를 정해놓고 행동을 만들면 Strategy라고 할 수 있다.

 또한, 여기에서 StrategyCallBack은 행동을 만드는 것을 클래스에서 따로만드는 것이 아니라, 그 때 그때마다 생성해주면 StrategyCallBack이라고 규정한다는 것만 기억하면 Strategy와 CallBack의 차이를 구분할 수 있다.
